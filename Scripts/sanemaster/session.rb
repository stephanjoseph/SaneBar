# frozen_string_literal: true

module SaneMasterModules
  # Session lifecycle management - insights extraction at session end
  # Inspired by Auto-Claude's automated insight extraction pattern
  module Session
    INSIGHT_CATEGORIES = {
      bug_pattern: {
        prompt: 'Any bug patterns discovered this session?',
        prefix: 'BugPattern',
        example: 'e.g., "await scheduleSegment hangs in offline mode"'
      },
      concurrency_gotcha: {
        prompt: 'Any concurrency gotchas worth remembering?',
        prefix: 'ConcurrencyGotcha',
        example: 'e.g., "MainActor.assumeIsolated crashes in deinit"'
      },
      architecture_pattern: {
        prompt: 'Any architecture decisions or patterns?',
        prefix: 'ArchPattern',
        example: 'e.g., "Use type erasure for macOS 26+ APIs"'
      }
    }.freeze

    def session_end(args)
      puts 'üîö --- [ SESSION END REVIEW ] ---'
      puts ''
      puts 'Checking for memory-worthy insights from this session...'
      puts '(Inspired by Auto-Claude insight extraction pattern)'
      puts ''

      insights = []
      skip_prompts = args.include?('--skip-prompts')

      if skip_prompts
        puts '‚è≠Ô∏è  Skipping interactive prompts (--skip-prompts)'
        show_session_summary
        return
      end

      INSIGHT_CATEGORIES.each do |category, config|
        insight = prompt_for_insight(category, config)
        insights << insight if insight
      end

      if insights.empty?
        puts ''
        puts '‚úÖ No new insights to record. Session complete!'
        show_session_summary
        return
      end

      # Record insights to memory
      puts ''
      puts "üìù Recording #{insights.count} insight(s) to memory..."
      insights.each do |insight|
        auto_record(insight[:type].to_s, insight[:name], insight[:observations])
      end

      puts ''
      puts '‚úÖ Session insights saved!'
      generate_handoff
      show_session_summary
    end

    def generate_handoff
      handoff_path = File.join(Dir.pwd, '.claude', 'SESSION_HANDOFF.md')
      FileUtils.mkdir_p(File.dirname(handoff_path))

      # Gather info
      recent_commits = `git log --oneline -10 --format='%h %s' 2>/dev/null`.strip.split("\n")
      git_status = `git status --short 2>/dev/null`.strip
      timestamp = Time.now.strftime('%Y-%m-%d %H:%M')

      content = <<~HANDOFF
        # Session Handoff - #{timestamp}

        ## Recent Commits
        #{recent_commits.map { |c| "- #{c}" }.join("\n")}

        ## Uncommitted Changes
        ```
        #{git_status.empty? ? '(none)' : git_status}
        ```

        ## In Progress
        <!-- Add notes about incomplete work -->

        ## Known Issues
        <!-- Add notes about bugs or problems -->

        ## Next Steps
        <!-- Add recommended next actions -->

        ---
        *Generated by `./Scripts/SaneMaster.rb session_end`*
      HANDOFF

      File.write(handoff_path, content)
      puts "üìã Handoff file generated: .claude/SESSION_HANDOFF.md"
    end

    private

    def prompt_for_insight(category, config)
      puts(config[:prompt])
      puts "   #{config[:example]}"
      print '   (y/n): '

      response = $stdin.gets&.chomp&.downcase
      return nil unless response == 'y'

      puts ''
      print '   Name (short, snake_case): '
      name = $stdin.gets&.chomp
      return nil if name.nil? || name.empty?

      # Clean up the name
      name = name.downcase.gsub(/\s+/, '_').gsub(/[^a-z0-9_]/, '')
      full_name = "#{config[:prefix]}_#{Date.today.strftime('%Y%m%d')}_#{name}"

      puts '   Enter observations (one per line, empty line to finish):'
      observations = []
      loop do
        print '   > '
        line = $stdin.gets&.chomp
        break if line.nil? || line.empty?

        observations << line
      end

      return nil if observations.empty?

      puts "   ‚úì Will record: #{full_name}"
      puts ''

      {
        type: category,
        name: full_name,
        observations: observations
      }
    end

    def show_session_summary
      puts ''
      puts 'üìä Session Summary:'

      # Show recent git activity
      recent_commits = `git log --oneline -5 --format='%s' 2>/dev/null`.strip.split("\n")
      if recent_commits.any?
        puts '   Recent commits:'
        recent_commits.each { |c| puts "     ‚Ä¢ #{c}" }
      end

      # Show memory stats with health info
      memory = load_memory
      if memory && memory['entities']
        entities = memory['entities']
        entity_count = entities.count
        by_type = entities.group_by { |e| e['entityType'] }
        type_summary = by_type.map { |t, e| "#{e.count} #{t}" }.join(', ')

        # Estimate tokens (~4 chars per token)
        estimated_tokens = (memory.to_json.length / 4.0).round

        puts "   Memory: #{entity_count} entities (~#{estimated_tokens} tokens)"
        puts "     Types: #{type_summary}"

        # Health warnings
        if entity_count > 60
          puts "   ‚ö†Ô∏è  Entity count HIGH (#{entity_count}/60) - consolidate!"
        end
        if estimated_tokens > 8000
          puts "   ‚ö†Ô∏è  Token count HIGH (~#{estimated_tokens}/8000) - may fill context!"
        end

        # Check for verbose entities
        verbose = entities.select { |e| (e['observations'] || []).count > 15 }
        if verbose.any?
          puts "   ‚ö†Ô∏è  #{verbose.count} verbose entities (>15 observations)"
        end
      end

      puts ''
      puts 'üí° Tips:'
      puts '   ‚Ä¢ Run `./Scripts/SaneMaster.rb mh` to check memory health'
      puts '   ‚Ä¢ Run `./Scripts/SaneMaster.rb mcompact --dry-run` to preview compaction'
      puts '   ‚Ä¢ Run `./Scripts/SaneMaster.rb mp` to prune stale entries'

      # Show compliance report if audit log exists
      audit_log = File.join(Dir.pwd, '.claude', 'audit_log.jsonl')
      if File.exist?(audit_log) && File.size(audit_log).positive?
        require_relative 'compliance_report'
        SaneMasterModules::ComplianceReport.generate
      end
    end
  end
end
